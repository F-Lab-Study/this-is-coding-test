# 공유기 설치

## 문제

도현이의 집 N개가 수직선 위에 있습니다. 각각의 집의 좌표는 X1, X2, ..., Xn이고, 집 여러 개가 같은 좌표를 가지는 일은 없습니다.<br>
도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 합니다.<br>
최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고,<br>
가장 인접한 두 공유기 사이의 거리를 가능한 크게하여 설치하려고 합니다.

C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하게요.

### 제한 조건

* 풀이 시간 : 1시간
* 시간 제한 : 2초
* 메모리 제한 : 128MB

### 입력 조건

* 첫째 줄에 집의 개수 N(2 <= N <= 200,000)과 공유기의 개수 C(2 <= C <= N)가 하나 이상의 빈칸을 사이에 두고 주어집니다.
* 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 Xi(1 <= Xi <= 1,000,000,000)가 한 줄에 하나씩 주어집니다.

```
5 3
1
2
8
4
9
```

### 출력 조건

* 첫째 줄에 가장 인접한 두 공유기 사이의 최대 거리를 출력합니다.

```
3
```


## 접근

수직선 상에 집들이 존재하고, 집들의 좌표가 존재하므로, 입력된 집의 좌표들을 정렬한다.<br>
정렬은 Collections.sort()를 사용하며 O(NlogN)이다.

최대한 많은 곳에서 공유기를 사용하게 하려면, 공유기가 최대한 고르게 분산되어 있어야 하므로 중간 지점을 활용한다.

중간 지점을 찾으려면 중간 값을 사용하는 이진 탐색을 활용한다.

공유기의 갯수가 유동적 홀수일 때와 짝수일 경우를 나눠서 진행한다.

```
ipTime = 3
List<Integer> installPosition

if (ipTime % 2 == 0):
    mid = (0 + houseList.size() - 1) / 2
    binarySort(houseList, 0, mid)
    binarySort(houseList, mid + 1, houseList.size() - 1)

binarySort(houseList, 0, houseList.size() - 1)

function binarySort(arr, front, rear):
    mid = (front + rear) / 2
    
    if (ipTime =< 0):
        return
    
    istallPosition.add(mid)
    ipTime -= 1
    
    binarySort(arr, front, mid)
    binarySort(arr, mid + 1, rear)
```

탐색이 완료되면 설치된 각 위치의 차이 값을 구하여 출력한다.

### 풀이 이슈

이번 풀이는 접근이 반만 맞았다.<br>
사실 이진 탐색 기출 풀이니까 당연히 이진 탐색을 선택해서 그렇지, 그냥 완전히 틀렸다고 봐도 될 것 같다.

이 문제는 최대 거리라는 표현을 쓰지만 `최소 거리`에 포인트를 두고 접근해야 한다.

예를 들어 좌표가 1 ~ 9까지 있고 설치해야 할 공유기의 갯수가 3개라고 해보자.<br>
공유기를 가장 이상적으로 설치하려면 다음과 같이 1, 4, 7에 설치하면 된다.

> **1** 2 3 **4** 5 6 **7** 8 9

이를 통해 설치된 공유기 간의 거리 간격이 3이라는 것을 알 수 있다.<br>
결과적으로 `1 - 9 사이의 집에 3개의 공유기를 설치하려면, 최소 3 이상의 거리에 있는 집에 설치해야 한다`라는 결론을 얻을 수 있다.

이 내용을 이진 탐색에 적용하면 `거리를 탐색 범위로 잡고, 설치 가능한 공유기의 개수에 따라 거리의 탐색 범위를 좁히며 조건을 만족하는 거리를 찾는다`가 된다.<br>
그리고 찾아야 하는 것은 `최소 거리 이상에 설치된 공유기들 중 가장 인접한(가까운) 공유기 사이의 거리`가 된다.<br>
이 말을 문제에서 요구하는 `최대 거리`에 초점을 맞추면 `설치 가능한 공유기 갯수 조건을 만족하는 거리 중 최대 거리`가 된다.
조건을 만족하는 최대 거리는 UpperBound에 해당한다.

* 첫번째 좌표에는 무조건 공유기를 설치한다.
* 최소 거리(1)와 최대 거리(첫번째 집의 좌표와 마지막 집의 좌표의 차이)의 중간값을 찾는다.
* 중간값을 기준으로 설치할 수 있는 공유기의 댓수를 확인한다.
* 설치할 수 있는 공유기의 댓수가 지정된 공유기 댓수보다 적으면 중간값 이상의 거리는 무의미하므로 최대 거리에 중간값을 저장한다.
* 설치할 수 있는 공유기의 댓수가 지정된 공유기 댓수보다 크거나 같으면 중간값 이하의 거리는 무의미하므로 최소 거리에 (중간값 + 1)을 저장한다.
* 최소 거리가 최대 거리보다 작으면 반복한다.
* 반복이 종료되면 (최종 거리 - 1)을 한 값을 출력한다.

UpperBound가 탐색을 종료한 후에 각 공유기 간의 거리를 비교해보지 않는 이유는 `결과값이 공유기를 N개 설치하기 위해서 필요한 최소 거리이며, 무조건 1개는 존재`하기 때문이다.

<br>

> [오답 코드](https://github.com/Java-Algorithm-Study-Group/this-is-coding-test/blob/main/seungjun/src/binary_search/Daily29.java)<br>
> [정답 코드](https://github.com/Java-Algorithm-Study-Group/this-is-coding-test/blob/main/seungjun/src/binary_search/Daily29Answer.java)
