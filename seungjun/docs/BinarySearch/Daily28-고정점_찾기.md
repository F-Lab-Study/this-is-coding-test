# 고정점 찾기

## 문제

고정점이란, 수열의 원소 중에서 `그 값이 인덱스와 동일한 원소`를 의미합니다.<br>
예를 들어 수열 a={-15, -4, 2, 8, 13}이 있을 때 a[2]=2이므로, 고정점은 2가 됩니다.

하나의 수열이 N개의 서로 다른 원소를 포함하고 있으며, 모든 원소가 오름차순으로 정렬되어 있습니다.<br>
이 때 이 수열에서 고정점이 있다면, 고정점으 출력하는 프로그램을 작성하세요.<br>
고정점은 최대 1개만 존재합니다. 만약 고정점이 없다면 -1을 출력합니다.

단, 이 문제는 시간 복잡도 O(logN)으로 알고리즘을 설계하지 않으면 '시간 초과' 판정을 받습니다.

### 제한 조건

* 풀이 시간 : 1시간
* 제한 시간 : 1초
* 메모리 제한 : 128MB

### 입력 조건

* 첫째 줄에 N(1 <= N <= 1,000,000)이 입력됩니다.
* 둘째 줄에 N개의 원소가 정수 형태로 공백으로 구분되어 입력됩니다.<br>(-10^9 <= 각 원소의 값 <= 10^9)

```
5
-15 -6 1 3 7
```

```
7
-15 -4 2 8 9 13 15
```

```
7
-15 -4 3 8 9 13 15
```

### 출력 조건

* 고정점을 출력합니다.
* 고정점이 없다면 -1을 출력합니다.

```
3
```

```
2
```

```
-1
```


## 접근

정렬된 수열에서 특정 조건의 값을 찾는 것은 이진 탐색이며, O(logN)의 시간 복잡도를 가진다.

문제에서 제시된 요구 사항은 `인덱스와 그 값이 동일한 원소`다.

정렬된 수열에서의 탐색이므로 

* front가 rear보다 작은 동안 
* 값이 인덱스보다 작을 경우 오른쪽 탐색
* 값이 인덱스보다 클 경우 왼쪽 탐색

을 반복한다.

```
binary_search(arr):
    front = 0
    rear = arr.length - 1
    
    while(front < rear):
        mid = (front / rear) / 2
        
        if (arr[mid] == mid)
            return arr[mid]
        
        if (arr[mid] < mid):
            front = mid + 1
        
        if (arr[mid] > mid):
            rear = mid - 1
            
    if (arr[rear] == rear):
        return arr[rear]
    
    return -1
```

### 풀이 이슈

정답은 맞았으나 1가지 아쉬운 점이 있다.

바로 while 루프 조건을 `front <= rear`로 줬으면, 루프 후에 굳이 한번 더 검사할 필요가 없어진다는 것이다.<br>
코드를 작성할 때, 조금만 더 신중하자.

> [작성 코드](https://github.com/Java-Algorithm-Study-Group/this-is-coding-test/blob/main/seungjun/src/binary_search/Daily28.java)