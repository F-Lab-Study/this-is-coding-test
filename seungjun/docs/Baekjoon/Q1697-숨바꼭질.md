# 숨바꼭질

## 문제

수빈이는 동생과 숨바꼭질을 하고 있다.<br>
수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. <br>
만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

## 접근

수빈이의 위치가 X이고 1초마다 X-1, X+1, X*2 3가지로 이동할 수 있다.<br>
이것은 1초마다 경로가 n^3개로 증가하는 그래프가 된다는 말이다.<br>
그리고 n초가 지났을 때 X의 값이 K가 되는 최소 이동 경로를 찾는 문제가 된다.<br>
일정한 간격과 방향성을 가지는 그래프의 최소 이동 경로 탐색은 BFS를 사용해야 한다.<br>

1. 루프 시작 전에 {depth, X} 쌍을 Queue에 넣는다.
2. Queue의 값을 가져온다.
3. HashSet에 현재 노드의 위치를 저장한다.
4. X가 0 ≤ N ≤ 100,000 범위에 있는지 확인 후, 범위 밖이면 연산을 패스한다.
5. X가 K인지 비교 후, K가 아니라면
   1. HashSet에 X-1이 존재 하지 않는다면, {depth+1, X-1}를 Queue에 넣는다.
   2. HashSet에 X+1이 존재 하지 않는다면, {depth+1, X+1}를 Queue에 넣는다.
   3. HashSet에 X*1이 존재 하지 않는다면, {depth+1, X*2}를 Queue에 넣는다.
6. X가 K이면 연산을 종료 후 depth를 출력 후 루프를 빠져나온다.
7. Queue가 0일 때까지 while문으로 2~6의 과정을 반복한다.

5번의 과정에서 hash set에 값이 존재하는 이유는 X에 대해서 +1, -1, *2 연산을 한 번 했다면, 이후 동일한 X값이 나왔을 때 나올 경우의 수는 이전에 나왔던 X와 동일하기 때문이다.
결과적으로 이미 나왔던 수에 대해서는 다시 고려할 필요가 없다.

### Queue

Queue를 사용하는 이유는 현재 위치에서 아직 방문하지 않은 다음 노드의 정보를 저장하기 위함이다.<br>
Queue에 사용되는 add, poll 메서드는 FIFO의 형태를 활용하는 구조로 add는 rear만 바라보면 되고, poll은 front만 바라보면 되기 때문에 O(1)의 시간 복잡도를 가진다.

### Set

Set의 경우에는 방문한 노드의 정보를 저장한다.<br>
Set에서 사용되는 add와 contains 메서드는 내부적으로 hash function을 사용하기 때문에 O(1)의 시간 복잡도를 가진다. 


