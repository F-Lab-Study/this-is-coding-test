# [토마토](https://www.acmicpc.net/problem/7576)

## 문제

철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다.<br>
토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다.

![토마토 상자](https://upload.acmicpc.net/de29c64f-dee7-4fe0-afa9-afd6fc4aad3a/-/preview/)

창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다.<br>
보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다.<br>
하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다.<br>
대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다.<br>
철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다.

토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라.<br>
단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.

### 제한 조건

* 시간 제한 : 1초
* 메모리 제한 : 256MB

### Input

* 첫 줄에는 상자의 크기를 나타내는 두 정수 M,N이 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M,N ≤ 1,000 이다. 
* 둘째 줄부터는 하나의 상자에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 상자에 담긴 토마토의 정보가 주어진다. 
* 하나의 줄에는 상자 가로줄에 들어있는 토마토의 상태가 M개의 정수로 주어진다. 
* 정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 
* 토마토가 하나 이상 있는 경우만 입력으로 주어진다.

```
6 4
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 1
```
```
6 4
0 -1 0 0 0 0
-1 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 1
```
```
6 4
1 -1 0 0 0 0
0 -1 0 0 0 0
0 0 0 0 -1 0
0 0 0 0 -1 1
```
```
5 5
-1 1 0 0 0
0 -1 -1 -1 0
0 -1 -1 -1 0
0 -1 -1 -1 0
0 0 0 0 0
```
```
2 2
1 -1
-1 1
```

### Output

* 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다. 
* 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.

```
8
```
```
-1
```
```
6
```
```
14
```
```
0
```

## 접근

해당 문제는 인접 토마토가 익으면, 그 다음 인접 토마토가 익는다는 조건이 있다.<br>
즉, 인접 노드들을 먼저 방문 후, 방문한 노드들의 인접 노드를 방문하므로 BFS 알고리즘을 활용해야 한다.<br>

그다음 고려해야 할 점은 시작 노드를 찾는 것과 방문하지 못한 노드를 찾는 것이다.

BFS의 시간 복잡도는 O(간선의 수 + 정점의 수)이므로 (M*N) + ((M-1)*(N-1))이고, 약 2,000,000 정도가 된다.<br>
그리고 시작 노드를 찾기 위해 모든 정점을 조사하는 M*N은 약 1,000,000이다.<br>
방문하지 못한 노드를 찾기 위해 모든 정점을 조사하는 M*N은 약 1,000,000이다.<br>
결과적으로 약 4,000,000번의 연산이 이루어지므로 1초 안에 결과를 얻을 수 있다.

1. (1, 1)부터 노드의 값을 조사하여 값이 1인 노드의 좌표를 모두 찾는다.
2. 1번에서 구한 노드들의 값을 0으로 변경한 후 Queue에 넣는다.
3. 각 노드들을 방문한다.<br>
BFS 알고리즘은 다음과 같은 조건을 확인한다.
* 노드의 값이 0일 때만 방문한다.
* 상하좌우로 이동한다.
* 다음 방문할 노드의 좌표가 상자의 범위 안에 있을 때만 방문한다.
* 노드를 방문할 때마다 직전 노드의 값에 1을 더한 값을 저장한다.
* 방문한 노드의 값이 가장 크면 해당 노드의 값을 저장한다.
* 인접 노드가 없으면 종료한다.<br>
알고리즘이 종료되면 시작 노드들의 값을 다시 1로 변경한다.
4. 노드의 값이 0인 좌표가 존재하는지 확인한다.
5. 0인 노드가 존재하면 -1, 존재하지 않으면 마지막 방문 노드의 값을 출력한다.

**=> 풀이 실패**

> [작성 코드](https://github.com/Java-Algorithm-Study-Group/this-is-coding-test/blob/main/seungjun/src/baekjoon/q7576/Main.java)