# 안테나

## 문제

일직선상의 마을에 여러 채의 집이 위치해 있습니다. 이 중에서 특정 위치의 집에 특별히 한 개의 안테나를 설치하기로 결정했습니다.<br>
효율성을 위해 안테나로부터 모든 집까지의 거리의 총 합이 최소가 되도록 설치하려고 합니다.<br>
이 때 안테나는 집이 위치한 곳에만 설치할 수 있고, 논리적으로 동일한 위치에 여러 개의 집이 존재하는 것이 가능합니다.<br>
집들의 위치 값이 주어질 때, 안테나를 설치할 위치를 선택하는 프로그램을 작성하세요.

### 제한 조건

* 풀이 시간 : 20분
* 시간 제한 : 1초
* 메모리 제한 : 256MB

### Input

* 첫째 줄에 집의 수 N(1 <= N <= 200,000)이 자연수로 주어집니다.
* 둘째 줄에 N채의 집에 위치가 공백으로 구분되어 1 이상 100,000 이하의 자연수로 주어집니다.

```
4
5 1 7 9
```

### Output

* 첫째 줄에 안테나를 설치할 위치의 값을 출력한다.
* 안테나를 설치할 수 있는 위치 값으로 여러 개의 값이 도출될 경우 가장 작은 값을 출력합니다.

```
5
```

## 접근

안테나로부터 모든 집까지의 거리의 총 합이 최소가 되려면, 안테나의 위치가 최대한 중앙에 위치하는 것이 유리하다.<br>
입력된 집의 위치를 정렬 후 가장 먼 집과 가까운 집의 평균 위치 값을 구한다.<br>
그 다음 평균값과의 거리차가 가장 적은 위치의 집에 안테나를 설치한다.

최대 200,000개의 집이 존재할 수 있고, 입력된 집들을 Collections.sort를 통해 O(NlogN)의 시간 복잡도로 정렬할 수 있다.<br>
이 후 거리차를 계산하는데 O(N)의 시간 복잡도가 필요하므로 결과적으로는 O(NlogN)의 시간 복잡도로 풀이가 가능하다.

### 풀이 이슈

"들어올 수 있는 경우의 수가 다양하니 중간 인덱스가 항상 최소 합을 보장할 수 있을까"라는 의문이 들었고, 그래서 하나씩 검증하는 로직을 작성했다.<br>
하지만 풀이를 보니 그냥 (houseCount / 2)를 사용한다. 나는 굳이 하지 않아도 될 로직를 작성한 것이다.<br>
문제를 풀 때 과장되게 생각해서 풀이 과정을 부풀리게 된 것이다.<br> 
앞으로는 의문이 드는 부분이 있다면, 의심만 하지 말고 가장 단순한 예제 케이스를 만들어서 검증하고 불필요한 로직을 걸러내도록 해야겠다.

> [풀이 코드](https://github.com/Java-Algorithm-Study-Group/this-is-coding-test/blob/main/seungjun/src/sorting/Daily24.java)