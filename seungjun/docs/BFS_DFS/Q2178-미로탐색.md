# [미로탐색](https://www.acmicpc.net/problem/2178)

## 문제

N×M크기의 배열로 표현되는 미로가 있다.

1 0 1 1 1 1<br>
1 0 1 0 1 0<br>
1 0 1 0 1 1<br>
1 1 1 0 1 1

미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다.<br> 
이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오.<br> 
한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.

위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다.<br> 
칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.

### 제한 조건

* 시간 제한 : 1초
* 메모리 제한 : 192MB

### Input

* 첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 
* 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.

```
4 6
101111
101010
101011
111011
```

```
4 6
110110
110110
111111
111101
```

### Output

* 첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 
* 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.

```
15
```

```
9
```

## 접근

N*M 형태의 배열은 그 자체로 그래프가 될 수 있다.<br> 
또한 시작 지점(1, 1)과 종료 지점(N, M)이 정해져 있는 최소 이동 경로는 BFS를 사용해서 구해야 한다.<br>
인접 노드들을 우선 방문 후, 방문한 노드의 인접 노드들을 방문하는 BFS의 특성을 통해 시작 노드으로부터 각 노드들까지의 이동횟수를 구할 수 있기 때문이다.

* 그래프 상에서의 이동방향은 상, 하, 좌, 우이다.
* 시작 노드의 값을 1이라고 했을 때, 인접 노드를 방문할 때마다 직전 노드의 값에 1을 더한다.
* Queue를 사용하여 다음 방문할 노드와 방문해야 하는 노드 정보를 저장한다.
* 이동해야 할 노드가 미로의 범위를 벗어나 Queue에 넣지 않는다.
* 이동해야 할 노드의 값이 0이면 Queue에 넣지 않는다.
* 현재 노드의 좌표가 (N, M)이면 종료한다.

> [작성 코드](https://github.com/Java-Algorithm-Study-Group/this-is-coding-test/blob/main/seungjun/src/bfs_dfs/q2178/Main.java)