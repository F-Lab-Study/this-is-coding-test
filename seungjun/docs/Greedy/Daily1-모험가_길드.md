# [모험가 길드]()

## 문제

모험가가 느끼는 공포도를 X라고 할 때, 안전을 위해 공포도 X를 느끼는 모험가는 안전을 위해 X명 이상으로 구성된 그룹에 속해 있어야만 모험을 떠날 수 있다.

N명의 모험가가 있을 때, 여행을 떠날 수 있는 그룹 수의 최댓값을 구해라.

단, N명의 모험가들 모두가 다 여행을 위한 그룹에 속하지 않아도 된다. 몇 명의 모험가는 마을에 남아 있어도 괜찮다.

## 예시

### Input

* 첫째줄에는 1 <= N <= 100000의 값을 입력한다.
* 두번째줄에는 N 이하의 값을 가진 모험가의 공포도 값을 N개 입력한다.

```
5
2 3 1 2 2
```

=> 공포도가 1, 2, 3인 모험가 그룹을 만들고, 남은 공포도가 2인 그룹을 만들어 2개의 그룹을 만들 수 있다. 

### Output

* 여행을 떠날 수 있는 그룹 수의 최댓값을 출력한다.

```
2
```

## 접근

### 1

그룹을 최대한 많이 만드려면 적은 인원으로도 모험이 가능한 그룹을 최대한 많이 만드는 것이 좋을 것이다.<br>
즉, 오름차순 정렬하여 공포도 순서대로 그룹을 만든다.<br>
그룹 수는 현재 배열의 공포도 값에 인덱스에 해당하는 배열값을 더한 값이 N을 넘지 않을 때 카운트한다.

```
array = array.sort()

groupCnt = 0
for (i = 0; i < N; i += array[i])
    if (i + array[i] < N)
        groupCnt++
```

=> 실패

공포도가 2인 모험가가 나와도 다음에 3인 모험가가 나오면 3명을 묶어야 한다. 즉, 다음 모험가의 공포도도 같이 고려해야 한다는 것이다.<br>
그러나 위 연산에서는 다음 모험가의 공포도가 고려되지 않았다.

### 2

1번과 비슷하게 오름차순으로 정렬하여 공포도가 낮은 순서대로 그룹을 구성한다.
추가적으로 다음 사람의 공포도를 고려하여 구성할 그룹의 인원수를 조절하도록 한다.

```
array = array.sort()

groupCnt = 0
i = 0
while (i < N)
    maxFear = array[i]
    for (j = i; j < i + array[i]; j++)
        if (maxFear < array[j])
            maxFear = array[j]
    
    i = maxFear
    
    groupCnt++
```

=> 풀이 실패

## 시간 복잡도

### 1

Arrays.sort() : O(nlog(n)) ~ O(n^2)
solution() : O(1) ~ O(n)